#Mattathias by Sam Crow
#an example of a pass-and-a-half transpiler

#grammar based on test.peg by Michael Ness
#and dcv.peg included with the PEG parser generator

%prefix "mb"
%header {
#include <string.h>
#include <malloc.h>
#include <errno.h>

#define VER_MAJOR 0
#define VER_MINOR 1
#define VER_RELEASE 0
	
enum RUNLEVEL {
	R_NORMAL=0,
	R_SRCOPEN,
	R_STATEHEADOPEN,
	R_STATEOPEN,
	R_FUNCOPEN,
	R_CONSTSOPEN,
	R_FILESOPEN
};

/* flags used internally by the compiler
	(must be powers of 2) */
#define COMPILE 1
#define DUMP 2
#define DEBUG 4

/* list of all variable and consant types */
enum TYPES {
	T_NONE=0,
	T_STRING,
	T_INT,
	T_FLOAT,
	T_STRINGVAR,
	T_INTVAR,
	T_FLOATVAR,
	T_WHILELOOP,
	T_FORLOOP,
	T_REPEATLOOP,
	T_DOLOOP,
	T_IF,
	T_PROCEDURE,
	T_FUNCTION,
	T_PRINT
};

struct operands {
	struct operands *op_ret;
	unsigned int op_type;
	unsigned int op_id;
};

/* list of all compiler errors */
enum COMPILEERRORS {
	E_OK=0,
	E_BAD_SYNTAX,
	E_TYPE_MISMATCH,
	E_BAD_ALLOC,
	E_INTERNAL
};
}
%source {
#define PCC_GETCHAR(auxil) fgetc(src)
#define PCC_ERROR(auxil) shutdown();

void setup();
void stackdump();
void stackunwind();
int shutdown();
int compile();
void helptext(char *);
bool push(unsigned int type);
struct operands *pop();
char getInput(char *);
void logger(char *);
void parsePrint();
void parseEnd();
void parseString(int , const char *);

FILE *statehead=NULL;
FILE *state=NULL;
FILE *funchead=NULL;
FILE *heaphead=NULL;
FILE *consts=NULL;
FILE *logfile=NULL;

FILE *src=NULL;

enum RUNLEVEL level;
enum COMPILEERRORS errorlevel=E_OK;

unsigned int idnum = 0;
unsigned int indentlevel=0;
unsigned int mode=0;

struct operands *opstack=NULL;

const char *COMPILEERRORNAMES[]={
	"no error",
	"incorrect syntax",
	"wrong type",
	"failed allocation",
	"internal compiler error"
};

const char *TYPENAMES[]={
	"none",
	"string",
	"integer",
	"floating point",
	"string variable",
	"integer variable",
	"floating point variable",
	"while loop",
	"for loop",
	"repeat loop",
	"do loop",
	"if statement",
	"procedure statement",
	"function statement",
	"print sequence"
};

const char *TYPEFORMATS[]={
	"",
	"s",
	"d",
	"f",
	"s",
	"d",
	"f"
};
}

START			<-	( Line EndOfLine )* Line EndOfFile

Line			<-	Label? Statements? Separator?

Statements		<-	SNGLQUOTE Comment
					/ Statement (Spacing Separator Statement)* Spacing

Comment			<-	( !(EndOfLine) .)*

Statement		<-	"REM" Comment
					/ "PRINT" {push(T_PRINT);} PrintExpr {parsePrint();}
					/ "IF" Spacing Expression ElseSequence?
					/ "ELSE"
					#elif appears in Amos manual but not in original compiler
					/ "ELIF" Spacing Expression ElseSequence
					/ "ENDIF"
					/ "WHILE" Spacing Expression
					/ "WEND"
					/ "DIM" Spacing DimElem ( COMMA DimElem )*
					/ "DO"
					/ "EXIT" Spacing (
						("WHEN" Spacing Expression)
						/ Expression
						)?
					/ "LOOP"
					/ "FOR" Spacing IntVar EQUAL Range ( "step" Spacing Expression )?
					/ "NEXT" ( Spacing IntVar )?
					/ "INC" Spacing IntVar
					/ "DEC" Spacing IntVar
					/ "ADD" Spacing IntVar Spacing COMMA Expression
						( Spacing COMMA Range )?
					/ "END" {parseEnd();}
					/ StringVar Spacing ASSIGN StringExpr
					/ FloatVar Spacing ASSIGN Expression
					/ IntVar Spacing ASSIGN Expression
					/ !(':' / EndOfLine / EndOfFile) ~{errorlevel=E_BAD_SYNTAX;}

StringVar		<-	< ID StringMark >

FloatVar		<-	< ID Floatmark >

IntVar			<-	< ID >

Label			<-	< ID > Separator

ElseSequence		<-	Spacing "THEN" Spacing Statements
						("ELSE" Spacing Statements)?

StringCond		<-	(StringExpr EQUAL StringExpr)
					/ (NOTEQUAL StringExpr)
					/ (GREATEREQUAL StringExpr)
					/ (LESSEQUAL StringExpr)
					/ (GREATER StringExpr)
					/ (LESS StringExpr)

LogicExpression		<-		Sum Spacing ( 
					(AND Sum
					/ OR Sum
					/ XOR Sum )
				Spacing )*

NumCond			<-		LogicExpression ( EQUAL LogicExpression
					/ NOTEQUAL LogicExpression
					/ GREATEREQUAL LogicExpression
					/ LESSEQUAL LogicExpression
					/ GREATER LogicExpression
					/ LESS LogicExpression )?

Cond			<-	( StringCond / NumCond ) Spacing

Expression		<-	Cond ( AND Cond
					/ OR Cond
					/ XOR Cond )*

PrintExpr		<-	( Spacing PrintVal PRINTSEPARATOR / COMMA )* PrintVal?

PrintVal		<-	StringExpr
				/ Expression Spacing

StringExpr		<-	StringVal Spacing (SIGN StringVal Spacing)*

StringFunction		<-	"CHR"
				/ "MID"
				/ "LEFT"
				/ "RIGHT"
				/ "SPACE"


StringVal			<-	DBLQUOTE 
						< ( !(DBLQUOTE / EndOfLine) .)* >
					DBLQUOTE  { parseString($1e-$1s, $1); }
					/ <StringFunction StringMark> Paramlist
					/ StringVar Paramlist
					/ StringVar !ASSIGN

Sum			<-	Product ( Spacing
					(
					PLUS Product
					/ MINUS Product
					)
				)*

Product			<-	Exponent ( Spacing
					( TIMES  Exponent
		                	/ DIVIDE Exponent
        		        	/ MODULO Exponent
        		        	)
				)*

Exponent	<-	Value ( Spacing POWER Value )*

IntFunction		<-	"SGN"
				/ "SQR"
				/ "LOG"
				/ "MIN"
				/ "MAX"
				/ "INT"
				/ "ABS"
				/ "RND"

IntValue		<-	NOT? IntUnary (
					IntFunction Paramlist
					/ IntVar Paramlist
					/ IntVar !ASSIGN
					/ Integer
				)

FloatFunction		<-	"SGN"
				/ "SQR"
				/ "LOG"
				/ "MIN"
				/ "MAX"
				/ "ABS"
				/ "LN"
				/ "EXP"
				/ "SIN"
				/ "COS"
				/ "TAN"
				/ "ASIN"
				/ "ACOS"
				/ "ATAN"
				/ "HSIN"
				/ "HCOS"
				/ "HTAN"

FloatValue		<-	FloatUnary (
					FloatFunction Paramlist
					/ FloatVar Paramlist
					/ FloatVar !ASSIGN
					/ Float
				)

Value			<-	FloatValue
				/ IntValue
				/ OPEN Expression CLOSE

Float			<-	< SIGN? [0-9]+ '.' [0-9]* (
					'e' SIGN [0-9]+
				)? > Spacing

Var			<-	FloatVar
				/ StringVar
				/ IntVar

DimArray		<-	Var Paramlist

DimElem			<-	( Var / DimArray ) Spacing

Range			<-	Expression Spacing TO Expression Spacing

#Paramlist denotes a function or an array
Paramlist		<-	OPEN Expression (Spacing COMMA Expression)* CLOSE

#these are placeholders for actions later on
IntUnary		<-	SIGN?

FloatUnary		<-	SIGN?

# Lexemes

SIGN			<-	PLUS / MINUS
Integer			<-	< SIGN? [0-9]+ > Spacing
ID			<-	IdentStart IdentCont*	
IdentStart		<-	[a-zA-Z_]
IdentCont		<-	[a-zA-Z_0-9]
LESS			<-	'<' Spacing
GREATER			<-	'>' Spacing
LESSEQUAL		<-	"<=" Spacing
GREATEREQUAL		<-	">=" Spacing
NOTEQUAL		<-	"<>" Spacing
EQUAL			<-	'=' Spacing
ASSIGN			<-	'=' Spacing
PLUS			<-	'+' Spacing
MINUS			<-	'-' Spacing
TIMES			<-	'*' Spacing
DIVIDE			<-	'/' Spacing
MODULO			<-	"MOD" Spacing
POWER			<-	'^' Spacing
OPEN			<-	'(' Spacing
CLOSE			<-	')' Spacing
#SQUAREOPEN		<-	'[' Spacing
#SQUARECLOSE		<-	']' Spacing
PRINTSEPARATOR		<-	';'  Spacing
AND			<-	"AND" Spacing
OR			<-	"OR" Spacing
XOR			<-	"XOR" Spacing
NOT			<-	"NOT" Spacing
COMMA			<-	',' Spacing
TO			<-	"TO" Spacing
SNGLQUOTE		<-	'\''
DBLQUOTE		<-	'\"'
StringMark		<-	'$'
Floatmark		<-	'#'
Spacing			<-	(' ' / '\t')*
EndOfFile		<-	!.
Separator		<-	':' Spacing
EndOfLine		<-	'\r\n' / '\n' / '\r'

%%

void parsePrint() {
	logger("print statement");
	if (mode & COMPILE) {
		struct operands *op=pop();
		bool more=true;
		do {
			if (op == NULL) {
				errorlevel=E_INTERNAL;
				return;
			}
			switch (op->op_type) {
				case T_STRING:
					fprintf(state,"printf(\"%%%s\", const%d);\\n",TYPEFORMATS[op->op_type], op->op_id);
					break;
				case T_PRINT:
					more=false;
					break;
				default:
					errorlevel=E_INTERNAL;
					return;
					break;
			}
			free(op);
			op=pop();
		} while (more);
	}
}

void parseEnd() {
	logger("end statement");
	if (mode & COMPILE) fprintf(state, "__statevar=__EXIT;\nbreak;\n");
}

void parseString(int length, const char *text) {
	logger("string pushed");
	if (mode & COMPILE) {
		if (push(T_STRING)) {
			fprintf(consts, "const unsigned int length%d=%d;\nconst char *constant%d=\"%s\";\n", opstack->op_id, length, opstack->op_id, text);
		} else {
			errorlevel=E_BAD_ALLOC;
		}
	}
}

/* stack support for operand stack */
bool push(unsigned int mytype) {
	struct operands *op=(struct operands *)malloc(sizeof(struct operands));
	if (op) {
		++indentlevel;
		op->op_type=mytype;
		++idnum;
		op->op_id=idnum;
		op->op_ret=opstack;
		opstack=op;
		return true;
	}
	return false;
}

struct operands *pop() {
	struct operands *op=opstack;
	if (op && op->op_ret) {
		--indentlevel;
		opstack=opstack->op_ret;
		return op;
	}
	return NULL;
}

/* write a note in the logfile */
void logger(char *contents) {
	unsigned int count;
	if (mode & DEBUG) {
		count=indentlevel;
		while (count > 0) {
			fputc('\t', logfile);
			--count;
		}
		fprintf(logfile, "%s\n", contents);
	}
}

/* Error handler */
void stackdump() {
	struct operands *op=pop();
	fprintf(stderr, "\nERROR: %s\n\nstackdump:\n", COMPILEERRORNAMES[errorlevel]);
	while (op) {
		fprintf(stderr, "operand of type %s\nnumber %d\n", TYPENAMES[op->op_type], op->op_id);
		free(op);
		op=pop();
	}
}

/* Unwind and deallocate stack nodes */
void stackunwind() {
	struct operands *op;
	while (((op=pop() ))) free(op);
}

/* open files and initialize them*/
void setup() {
	if (mode & COMPILE) {
		/* compile mode */
		statehead=fopen("state.h","w");
		if (statehead) {
			level=R_STATEHEADOPEN;
			state=fopen("state.c","w");
			if (state) {
				level=R_STATEOPEN;
				funchead=fopen("functions.h","w");
				if (funchead) {
					level=R_FUNCOPEN;
					consts=fopen("consts.h","w");
					if (consts) {
						level=R_CONSTSOPEN;
						heaphead=fopen("heap.h","w");
						if (heaphead) {
							level=R_FILESOPEN;
					
							fprintf(statehead,"#include <runtime.h>\nenum __state {__START=__NORMAL");
							fprintf(heaphead,"#include <runtime.h>\nstruct __heap {\nstruct __subroutine *__callStack;\n");
							fprintf(state,"#include \"state.h\"\n#include \"consts.h\"\n");
							fprintf(state,"#include \"heap.h\"\n#include \"functions.h\"\n");
							fprintf(state,"enum __state __statevar;\nint __stateloop(){\n__statevar=__START;\n");
							fprintf(state,"do{\nswitch(__statevar){\n");
						}
					}
				}
			}
		}
	}
	if (mode & DUMP) {
		/* dump identifier mode */
		logfile=fopen("parse.log","w");
		logger("Setup complete.");
	}
}

/* shutdown the compiler and exit */
int shutdown() {
	int retval=0;
	if  (errorlevel != E_OK) {
		logger("Dumping stack.");
		stackdump();
		retval=1;
	} else {
		stackunwind();
	}
	if (mode & DUMP && logfile != NULL) {
		fprintf(logfile, "Shutting down at runlevel %d and return value %d.\n", level, retval);
		fclose(logfile);
	}
	switch (level) {
		case R_FILESOPEN:
			fprintf(statehead, "};\n");
			fprintf(heaphead,"};\n");
			fprintf(state,"}\n}while(__statevar>__EXIT);\nreturn __statevar;\n}\n");
			fclose(heaphead);
		case R_CONSTSOPEN:
			fclose(consts);
		case R_FUNCOPEN:
			fclose(funchead);
		case R_STATEOPEN:
			fclose(state);
		case R_STATEHEADOPEN:
			fclose(statehead);
		case R_SRCOPEN:
			/*fclose(src);*/
		case R_NORMAL:
			return retval;
			break;
		default:
			return 1;
			break;
	}
}

/* open files and compile */
int compile() {
	mb_context_t *ctx;
	level=R_NORMAL;
	if (mode) {
		src=stdin;
		/*src=fopen(filename, "rb");
		if (src) { */
			level=R_SRCOPEN;
			setup();
		
			/* parse */
			ctx = mb_create(NULL);
			while(mb_parse(ctx, NULL)){}
			mb_destroy(ctx);
		/*}*/
	} else {
		printf("Did nothing.");
	}
	return shutdown();
}


/* print the help text to stdout */
void helptext(char *commandname) {
	printf("%s [-d|V|v] < filename.mb\n", commandname);
	printf("Compiles filename.mb by default unless a flag is specified.\n");
	printf("\n The optional flags are as follows:\n");
	printf("-d is a dump of identifiers to the parse.log file.\n");
	printf("-V is for a verbose build where the compiler dumps and compiles.\n");
	printf("-v prints the version and exits.\n\n");
}

/* process command line parameters */
int main(int argc, char *argv[]) {
	switch (argc) {
		case 1:
			mode=COMPILE;
			printf("\nCompile initiated.\n");
			return compile();
			break;
		case 2:
			if (argv[1][0]=='-') {
				switch (argv[1][1]) {
					case 'd':
						printf("\nIdentifier dump initiated.\n");
						mode=DUMP;
						return compile();
						break;
					case 'v':
						printf("\n%s version %d.%d.%d\n", argv[0], VER_MAJOR, VER_MINOR, VER_RELEASE);
						return 0;
						break;
					case 'V':
						printf("\nVerbose compile initiated.\n");
						mode=DUMP|COMPILE;
						return compile();
						break;
					case 'D':
						printf("\nCompiler debug and dump mode initiated.\n");
						mode=DUMP|DEBUG;
						return compile();
						break;
					default:
						helptext(argv[0]);
						break;
				}
			}
			break;
		default:
			helptext(argv[0]);
			break;
	}
	return 0;
}
